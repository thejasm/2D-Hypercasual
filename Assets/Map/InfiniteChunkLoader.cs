using UnityEngine;
using System.Collections.Generic;
using InteliMapPro;

public class InfiniteChunkLoader: MonoBehaviour {
    [Header("References")]
    public InteliMapGenerator inteliMapGenerator;
    public Camera mainCamera;

    [Header("Chunk Settings")]
    public int chunkSize = 25;
    public int loadRadius = 1;

    private Grid grid;
    private Vector2Int currentCamChunkCoord;
    private HashSet<Vector2Int> chunksBeingGenerated;
    private HashSet<Vector2Int> generatedChunks;

    void Start() {
        if (mainCamera == null) mainCamera = Camera.main;

        if (inteliMapGenerator == null) {
            Debug.LogError("InteliMapGenerator not assigned.");
            enabled = false;
            return;
        }

        // Store generatorData if you need to pass it to other InteliMap API calls.
        // For now, we're not directly using it in this script's logic beyond this point,
        // as the Generate call is assumed to be on inteliMapGenerator itself.
        object intelimapData = inteliMapGenerator.generatorData;
        if (intelimapData == null) {
            Debug.LogWarning("InteliMapGenerator.generatorData is null. This might be okay if not directly used by the Generate method.");
        }

        // Get the Grid component
        grid = inteliMapGenerator.GetComponentInParent<Grid>();
        if (grid == null) {
            Debug.LogError("Grid component not found on InteliMapGenerator's GameObject or its parents.");
            enabled = false;
            return;
        }

        chunksBeingGenerated = new HashSet<Vector2Int>();
        generatedChunks = new HashSet<Vector2Int>(); // Initialize our custom tracking
        currentCamChunkCoord = GetChunkCoordFromWorldPos(mainCamera.transform.position);
        LoadChunksAround(currentCamChunkCoord);
    }

    void Update() {
        Vector2Int newCamChunkCoord = GetChunkCoordFromWorldPos(mainCamera.transform.position);
        if (newCamChunkCoord != currentCamChunkCoord) {
            currentCamChunkCoord = newCamChunkCoord;
            LoadChunksAround(currentCamChunkCoord);
        }
    }

    Vector2Int GetChunkCoordFromWorldPos(Vector3 worldPos) {
        if (grid == null) return Vector2Int.zero; // Should not happen if Start was successful
        Vector3Int cellPos = grid.WorldToCell(worldPos);
        return new Vector2Int(
            Mathf.FloorToInt((float)cellPos.x / chunkSize),
            Mathf.FloorToInt((float)cellPos.y / chunkSize)
        );
    }

    void LoadChunksAround(Vector2Int centerChunkCoord) {
        for (int x = -loadRadius; x <= loadRadius; x++) {
            for (int y = -loadRadius; y <= loadRadius; y++) {
                TryGenChunk(new Vector2Int(centerChunkCoord.x + x, centerChunkCoord.y + y));
            }
        }
    }

    void TryGenChunk(Vector2Int chunkCoord) {
        // Check if we've already processed this chunk (told InteliMap to generate it)
        if (generatedChunks.Contains(chunkCoord)) {
            return;
        }

        // Check if InteliMap is currently busy generating this specific chunk (initiated by this script)
        if (chunksBeingGenerated.Contains(chunkCoord)) {
            return;
        }

        BoundsInt chunkBounds = new BoundsInt(
            chunkCoord.x * chunkSize, chunkCoord.y * chunkSize, 0,
            chunkSize, chunkSize, 1
        );

        chunksBeingGenerated.Add(chunkCoord); // Mark as "being generated by InteliMap"
        Debug.Log($"Requesting InteliMap generation for chunk: {chunkCoord} with Bounds: {chunkBounds.min} to {chunkBounds.max - Vector3Int.one}");

        inteliMapGenerator.boundsToFill = chunkBounds;
        inteliMapGenerator.StartGeneration();
    }


}
